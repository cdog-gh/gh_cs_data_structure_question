#  📋 해시 테이블
해시 계열 자료구조에서 나올 만한 면접 질문들을 모아 보았습니다.

### ⭐⭐⭐ hashMap의 구조가 어떻게 되는지 간단히 설명해 주세요.

### ⭐⭐⭐ hashCode와 Equals가 무엇인가요?
_equals_ 는 두 객체가 **동등**한지를 판단합니다. _hashCode_ 는 객체의 해시값을 리턴해 줍니다.
* 객체의 해시값은 hash 계열의 자료구조를 이용할 때 **들어갈 버킷의 번호를 계산** 하는 데 쓰입니다.


### ⭐ equals가 재정의 되지 않은 객체를 hashmap의 키로 삼았을 때 어떤 일이 일어나나요?
두 가지로 나눠 보겠습니다.
* _hashCode_ 가 정의되지 않았을 때
  * 자바의 경우, 객체의 고유 hash 값을 리턴합니다. 이 값은 두 객체가 동등하더라도 달라질 수 있습니다.
  * 따라서, 동등한 두 객체라도 **다른 버킷에 저장** 될 수 있습니다.

* _hashCode_ 만 정의된 경우 같은 버킷에 있지만, 두 객체가 동등하더라도 **다른 객체로 판단** 할 수 있습니다.
  * _override_ 가 되지 않았다면 _Object_ 의 _hashCode_ 를 호출하는데 이것은 두 객체의 참조값을 비교합니다.
  * 두 객체가 서로 다른 공간에 할당되어 있다면, **두 객체의 참조값** 역시 다릅니다.

### ⭐⭐⭐ 왜 equals를 오버라이딩하면 hashCode도 같이 오버라이딩하나요?
이유는 간단합니다. _hashCode_ 가 버킷을 찾는 역할을 하기 때문입니다. 만약에 _hashCode_ 가 구현되어 있지 않다면
* 동등한 객체이지만 다른 _hashCode_ 값이 나와서 엉뚱한 버킷에서 찾을 수 있을 겁니다.

### ⭐⭐⭐ equals가 오버라이딩 되고, hashCode가 모두 0을 리턴하도록 오버라이딩 된 객체를 key로 삼으면 어떤 일이 일어나나요?
_Java8_ 부터 _hashmap_ 혹은 _hashSet_ 에서 충돌이 많이 일어나면 _balanced Tree_ 형태로 _Chaining_ 을 시킵니다. 그래서 n개의 키가 들어가 있는 해시맵에서
* _Comparable_ 이 구현되어 있다면 _O(log(n))_ 에 수행합니다.
* _Comparable_ 과 같은 비교할 수 있는 무언가가 없다면 _O(n)_ 에 수행됩니다. 왜? 
  * 만약에 정렬 기준이 따로 없다면, 내부적으로 _hashCode_ 비슷하게 정렬 기준을 잡아버립니다.
  * 그러면 다른 기준이 _key_ 가 되고, 해시맵에서의 key는 _value_가 된 셈입니다.
  * hashmap에서 _key_ 값이 아닌 _value_ 가 _v_ 인 것을 찾기 위해서는 어떻게 해야 할까요?